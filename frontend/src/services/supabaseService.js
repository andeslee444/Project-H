import { supabase } from '../lib/supabase';\n\nclass SupabaseService {\n  // Authentication methods are handled by the useAuth hook\n  \n  // Practice Management\n  async getPractices() {\n    const { data, error } = await supabase\n      .from('practices')\n      .select('*');\n    \n    if (error) throw error;\n    return { data, success: true };\n  }\n\n  async createPractice(practiceData) {\n    const { data, error } = await supabase\n      .from('practices')\n      .insert(practiceData)\n      .select()\n      .single();\n    \n    if (error) throw error;\n    return { data, success: true };\n  }\n\n  // Provider Management\n  async getProviders(practiceId = null) {\n    let query = supabase\n      .from('providers')\n      .select(`\n        *,\n        practice:practices(*)\n      `);\n    \n    if (practiceId) {\n      query = query.eq('practice_id', practiceId);\n    }\n    \n    const { data, error } = await query;\n    if (error) throw error;\n    return { data, success: true };\n  }\n\n  async createProvider(providerData) {\n    const { data, error } = await supabase\n      .from('providers')\n      .insert(providerData)\n      .select()\n      .single();\n    \n    if (error) throw error;\n    return { data, success: true };\n  }\n\n  // Patient Management\n  async getPatients() {\n    const { data, error } = await supabase\n      .from('patients')\n      .select('*');\n    \n    if (error) throw error;\n    return { data, success: true };\n  }\n\n  async createPatient(patientData) {\n    const { data, error } = await supabase\n      .from('patients')\n      .insert(patientData)\n      .select()\n      .single();\n    \n    if (error) throw error;\n    return { data, success: true };\n  }\n\n  async getPatient(patientId) {\n    const { data, error } = await supabase\n      .from('patients')\n      .select('*')\n      .eq('patient_id', patientId)\n      .single();\n    \n    if (error) throw error;\n    return { data, success: true };\n  }\n\n  // Appointment Management\n  async getAppointments(filters = {}) {\n    let query = supabase\n      .from('appointments')\n      .select(`\n        *,\n        provider:providers(*),\n        patient:patients(*)\n      `);\n    \n    if (filters.provider_id) {\n      query = query.eq('provider_id', filters.provider_id);\n    }\n    if (filters.patient_id) {\n      query = query.eq('patient_id', filters.patient_id);\n    }\n    if (filters.start_date) {\n      query = query.gte('start_time', filters.start_date);\n    }\n    if (filters.end_date) {\n      query = query.lte('start_time', filters.end_date);\n    }\n    \n    const { data, error } = await query.order('start_time');\n    if (error) throw error;\n    return { data, success: true };\n  }\n\n  async createAppointment(appointmentData) {\n    const { data, error } = await supabase\n      .from('appointments')\n      .insert(appointmentData)\n      .select()\n      .single();\n    \n    if (error) throw error;\n    return { data, success: true };\n  }\n\n  async updateAppointment(appointmentId, updates) {\n    const { data, error } = await supabase\n      .from('appointments')\n      .update(updates)\n      .eq('appointment_id', appointmentId)\n      .select()\n      .single();\n    \n    if (error) throw error;\n    return { data, success: true };\n  }\n\n  // Appointment Slots\n  async getAppointmentSlots(filters = {}) {\n    let query = supabase\n      .from('appointment_slots')\n      .select(`\n        *,\n        provider:providers(*)\n      `);\n    \n    if (filters.provider_id) {\n      query = query.eq('provider_id', filters.provider_id);\n    }\n    if (filters.status) {\n      query = query.eq('status', filters.status);\n    }\n    if (filters.start_date) {\n      query = query.gte('start_time', filters.start_date);\n    }\n    if (filters.end_date) {\n      query = query.lte('start_time', filters.end_date);\n    }\n    \n    const { data, error } = await query.order('start_time');\n    if (error) throw error;\n    return { data, success: true };\n  }\n\n  async createAppointmentSlot(slotData) {\n    const { data, error } = await supabase\n      .from('appointment_slots')\n      .insert(slotData)\n      .select()\n      .single();\n    \n    if (error) throw error;\n    return { data, success: true };\n  }\n\n  // Waitlist Management\n  async getWaitlists(practiceId = null) {\n    let query = supabase\n      .from('waitlists')\n      .select(`\n        *,\n        practice:practices(*)\n      `);\n    \n    if (practiceId) {\n      query = query.eq('practice_id', practiceId);\n    }\n    \n    const { data, error } = await query;\n    if (error) throw error;\n    return { data, success: true };\n  }\n\n  async createWaitlist(waitlistData) {\n    const { data, error } = await supabase\n      .from('waitlists')\n      .insert(waitlistData)\n      .select()\n      .single();\n    \n    if (error) throw error;\n    return { data, success: true };\n  }\n\n  async getWaitlistEntries(waitlistId = null, patientId = null) {\n    let query = supabase\n      .from('waitlist_entries')\n      .select(`\n        *,\n        patient:patients(*),\n        waitlist:waitlists(*),\n        provider:providers(*)\n      `);\n    \n    if (waitlistId) {\n      query = query.eq('waitlist_id', waitlistId);\n    }\n    if (patientId) {\n      query = query.eq('patient_id', patientId);\n    }\n    \n    const { data, error } = await query.order('priority_score', { ascending: false });\n    if (error) throw error;\n    return { data, success: true };\n  }\n\n  async joinWaitlist(waitlistData) {\n    const { data, error } = await supabase\n      .from('waitlist_entries')\n      .insert(waitlistData)\n      .select()\n      .single();\n    \n    if (error) throw error;\n    return { data, success: true };\n  }\n\n  async updateWaitlistEntry(entryId, updates) {\n    const { data, error } = await supabase\n      .from('waitlist_entries')\n      .update(updates)\n      .eq('entry_id', entryId)\n      .select()\n      .single();\n    \n    if (error) throw error;\n    return { data, success: true };\n  }\n\n  // Patient Matching (Edge Function)\n  async findMatchingPatients(slotId, options = {}) {\n    const { data, error } = await supabase.functions.invoke('patient-matching', {\n      body: { \n        slot_id: slotId, \n        options \n      }\n    });\n    \n    if (error) throw error;\n    return data;\n  }\n\n  async findMatchingSlots(patientId, options = {}) {\n    const { data, error } = await supabase.functions.invoke('patient-matching', {\n      body: { \n        patient_id: patientId, \n        options \n      }\n    });\n    \n    if (error) throw error;\n    return data;\n  }\n\n  // Notifications\n  async getNotifications(recipientId) {\n    const { data, error } = await supabase\n      .from('notifications')\n      .select('*')\n      .eq('recipient_id', recipientId)\n      .order('created_at', { ascending: false });\n    \n    if (error) throw error;\n    return { data, success: true };\n  }\n\n  async createNotification(notificationData) {\n    const { data, error } = await supabase\n      .from('notifications')\n      .insert(notificationData)\n      .select()\n      .single();\n    \n    if (error) throw error;\n    return { data, success: true };\n  }\n\n  async markNotificationAsRead(notificationId) {\n    const { data, error } = await supabase\n      .from('notifications')\n      .update({ \n        status: 'read', \n        read_at: new Date().toISOString() \n      })\n      .eq('notification_id', notificationId)\n      .select()\n      .single();\n    \n    if (error) throw error;\n    return { data, success: true };\n  }\n\n  // Real-time subscriptions\n  subscribeToAppointments(callback, filters = {}) {\n    let channel = supabase\n      .channel('appointments')\n      .on(\n        'postgres_changes',\n        {\n          event: '*',\n          schema: 'public',\n          table: 'appointments',\n          ...(filters.provider_id && { filter: `provider_id=eq.${filters.provider_id}` })\n        },\n        callback\n      )\n      .subscribe();\n    \n    return () => supabase.removeChannel(channel);\n  }\n\n  subscribeToWaitlistEntries(callback, waitlistId = null) {\n    let channel = supabase\n      .channel('waitlist_entries')\n      .on(\n        'postgres_changes',\n        {\n          event: '*',\n          schema: 'public',\n          table: 'waitlist_entries',\n          ...(waitlistId && { filter: `waitlist_id=eq.${waitlistId}` })\n        },\n        callback\n      )\n      .subscribe();\n    \n    return () => supabase.removeChannel(channel);\n  }\n\n  subscribeToNotifications(callback, recipientId) {\n    let channel = supabase\n      .channel('notifications')\n      .on(\n        'postgres_changes',\n        {\n          event: 'INSERT',\n          schema: 'public',\n          table: 'notifications',\n          filter: `recipient_id=eq.${recipientId}`\n        },\n        callback\n      )\n      .subscribe();\n    \n    return () => supabase.removeChannel(channel);\n  }\n}\n\nexport const supabaseService = new SupabaseService();\nexport default supabaseService;